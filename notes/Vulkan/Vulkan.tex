\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{fullpage}
\usepackage{hyperref}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    pdftitle={Vulkan},
    pdfpagemode=FullScreen,
}

\title{Vulkan}
\author{Paolo Bettelini}
\date{}

\begin{document}

\maketitle
\tableofcontents
\pagebreak

\section{Vulkan}

Vulkan is a multi-platform low-level graphical interface (API)
for GPU rendering.

The GPU is able to perform computation on a lot of data simultaneously
(SIMD, Single Instruction stream, Multiple Data stream).

\section{Queue}

The GPU is able to run multiple operations in parallel.
The equivalent of a CPU thread is a \textbf{queue}.
Queues are grouped by \textbf{queue families}.

Whenever we want the device to perform an operation,
we have to submit this operation to a specific queue under a family.
Some queues support only graphical operations,
some others support only compute operations, and some others support both.

\section{Buffers}

When we need the GPU to read or write data in memory,
we need to use a \textbf{buffer} (or an image, later section).

\section{Command buffers}

To execute an operation we need to create a command buffer
containg a list of commands to execute.

To submit a command buffer we need to synchronize with the GPU.
We can also tell the GPU to send back a signal, call \textbf{fence} when
the operation is done.

\subsection{Primary command buffers}

They can contain any command.
They are the only type of command buffer that can be submitted to a queue.

\subsection{Secondary command buffers}

They allow you to store functionality that you can reuse multiple times in primary command buffers. 

\section{Compute pipelines}

In order to ask the GPU to perform an operation on some data, we need to write
a program for it. A program that runs on the GPU is called a shader.

Shaders are written in a shading language (hlsl, glsl, wgpu, rust-gpu, ...)
which is then compiled into an intermediate bytecode called \textbf{SPIR-V}.

\section{Descriptors}

When we create a compute pipeline for a shader we must bound it to a \textbf{descriptor}.
A descriptor can contain a buffer to access, buffer viewes, images, samples images etc.

Descriptors are grouped by \textbf{descriptor sets}.
The shader will declare a specific descriptor from a specific set (both indexed from 0).

\section{Dispatch}

To execute a compute pipeline we need to create a command buffer to do so.
This is called \textbf{Dispatch}.

% The layout(set = 0, binding = 0) attribute in the GLSL code indicates that this descriptor
% is the descriptor 0 in the set 0. Descriptor indices and set indices are 0-based.

\section{Images}

Another way to make the GPU interact with memory is with an \textbf{image}.
Images are often 2-dimensional array of pixels (there also also 3-dimensional images). The pixels of the image
are often referred to as \textbf{texels}.

Each pixel can have up to four components.

You can't directly change the content of an image as you would for a buffer.
For example, we could create a command buffer to tell the GPU to fill an image with white pixels.

\section{Graphics pipelines}

A graphics pipeline is the same as a compute pipeline but for graphical operations.
Graphics pipelines are more restrictive than compute operations, but they're also much faster.

The purpose of this pipeline is to draw a shape on an image.

\subsection{Vertex shaders}

The first step when executing a graphics operation is the \textbf{vertex shader}.
This shader is executed for each vertex of the shape.

\subsection{Fragment shaders}

The GPU will compute which pixels are in the given shape, and
will execute for each of them the \textbf{fragment shader}.

\subsection{Vertex buffer}

Vertex buffer is the name given the the buffer containing the certices of the shape.
The shape is made out of triangles (3 vertices each).

\subsection{Render passes}

Before executing a graphics operation we must tell the GPU to enter a "rendering mode",
by entering what is called a \textbf{render pass}.

A render pass is made of \textbf{attachments} and \textbf{passes}.

% creat an instance
% enumerate physical devices and pick one
% get a family that supported graphics
% create a device (represents an open channel with the physical device) 
%   with the family
%   this will return the device and the queues
% [ COMMAND
%   Create buffer(s)
%   Create primary command buffer
%   sync cpu
% ]
% [ COMPUTE SHADER
%   create buffer
%   create descriptor
%   create compute shader
%   create compute pipeline (shader)
%   bind descriptor
%   create command buffer to execute pipeline. (Dispath)
%   sync
% ]
% [ GRAPHICS SHADER
%   create vertex shader
%   create fragment shader
%   create graphics pipeline (vertex, fragment)
%   create N buffers containing the vertices
%   create a framebuffer which is a collection of images to write to.
%   create command_buffer
%   sync
% ]

\end{document}

% https://vulkano.rs/guide/


https://vulkano.rs/guide/compute-pipeline
workgroups

https://vulkano.rs/guide/what-graphics-pipeline