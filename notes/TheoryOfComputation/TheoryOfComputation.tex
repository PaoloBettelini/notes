\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{bettelini}

\usetikzlibrary{ % tikz packages
    automata,positioning,
    arrows.meta,bending
}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    pdftitle={TheoryOfComputation},
    pdfpagemode=FullScreen,
}

\tikzset{every state/.style={
    inner sep=2pt,
    minimum size=4pt
}}
\tikzset{>=stealth}  %latex, to, stealth

\title{Theory of Computation}
\author{Paolo Bettelini}
\date{}

% Empty string symbol.
\newcommand{\emptyString}{\lambda}

\begin{document}

\maketitle
\tableofcontents
\pagebreak

\section{Fields of Study}

\subsection{Complexity Theory}

Classify problems according to their degree
of "difficulty".

\subsection{Computability Theory}

Classify problems as being solvable or unsolvable.

\subsection{Automata Theory}

Compare different computation models.

\section{Alphabets and Languages}

An \textit{alphabet} is a finite set of \textit{symbols}.
For example: \(\{a,b,c,\cdots, z\}\)\\
The set \(\{0,1\}\) is the binary set.
The empty string is denoted \(\emptyString\).
\\
Note that \(\emptyString \neq \varnothing \neq \{\emptyString\}\).
\\
The length of a string \(w\) is denoted as \(|w|\).

If \(\Sigma\) is an alphabet,
\[
    \Sigma_\emptyString = \emptyString \union \Sigma
\]

A set of strings is called a \textit{language}.

\section{Deterministic Finite Automaton}

A deterministic finite automaton (DFA) is a state-machine which processes a string
symbol by symbol from left to right. The automaton is in one of his \textit{states}
after processing a symbol. The machine might terminate in an
\textit{accept state} or not.

A DFA \(M=(Q, \Sigma, \delta, q, F)\)
\begin{itemize}
    \item \(Q\) is a finite set of \textit{states}
    \item \(\Sigma\) is an alphabet
    \item \(\delta : Q \times \Sigma \to Q\) is the \textit{transition function}
    \item \(q\) is an element of \(Q\) called the \textit{start state}
    \item \(F\) is a subset of \(Q\) which contains the \textit{accept states}
\end{itemize}
The transition function is the logical components, it determines
in which state the machine will be after processing a symbol at any state.

The following automaton processes a binary string.
The start state is \(q_1\) and the only accept state is \(q_3\).
The program moves to the next state only if the symbol is \(1\),
so it will reach \(q_3\) only if the input string contains at least two \(1\)s.
\begin{center}
    \begin{tikzpicture}[node distance=2cm,on grid,auto]
        \node[state] (q1) {\(q_1\)};
        \node (inv) [left=of q1] {};

        \node[state] (q2) [right=of q1] {\(q_2\)};
        \node[state, accepting] (q3) [right=of q2] {\(q_3\)};

        \path[->]
            (inv)
                edge node {} (q1)
            (q1)
                edge node {\(1\)} (q2)
                edge[loop above] node {\(0\)} ()
            (q2)
                edge node {\(1\)} (q3)
                edge[loop above] node {\(0\)} ()
            (q3)
                edge[loop above] node {\(0\)} ();
    \end{tikzpicture}
\end{center}


If a DFA is in a state \(r\) and it reads the symbol \(a\),
then it will uniquely switch to the state \(\delta(r, a)\)

\pagebreak

The language of \(M\), denoted \(L(M)\) is the set of all accepted strings
by \(M\).
\[
    L(M) = \{w \in \Sigma^* \suchthat M\text{ accepts }w\}
\]

\section{Operations}

\subsection{Concatenation}

If \(A\) and \(B\) are two languages over the same alphabet,
the concatenation of \(A\) and \(B\) is defined as
\[
    AB = \{ab \suchthat a \in A \land b \in B\}
\]

\subsection{Kleene star operator}

The kleene star operator can be applied to alphabets or languages.
It represent the union of all \(n\)-permutations of the set. \\
The set \(\{0,1\}^*\) is the set of
all binary strings. If \(\Sigma\) is an alphabet, \(\Sigma^*\) is the set
of all strings over \(\Sigma\)
\[
    \Sigma^* = \emptyString \cup \bigcup_{n\in\mathbb{N}} \Sigma^n
\]

\section{Regular language}

A language is regular if it can be expressed as a regular expression,
or if an automaton that accepts said language exists.
\(A\) is regular iff
\[
    \exists M \suchthat L(M) = A
\]

\subsection{Closure under union (extra)}

\textit{If \(A\) and \(B\) are two regular languages over the same alphabet
\(\Sigma\), then \(A \union B\) is also regular.}

We can prove this by making a DFA that accepts both languages.
Let's say that \(M_1=(Q_1, \Sigma, \delta_1, q_1, F_1)\) accepts \(A\)
and \(M_2=(Q_2, \Sigma, \delta_2, q_2, F_2)\) accepts \(B\).
The automaton \(M=(Q, \Sigma, \delta, q, F)\) must run \(M_1\) and \(M_2\) \textit{simultaneously},
so any state must represent the current states of \(M_1\) and \(M_2\).
This means that the states of \(M\) must represent any combination of state between
\(M_1\) and \(M_2\), meaning \(Q=Q_1 \times Q_2\).
The transition function is now in the form
\(\delta((r_1, r_2), a) = (\delta_1(r_1, a), \delta_2(r_2, a))\) where \(a\in\Sigma\).
The initial state is the state in \(Q\) which contains the initial state of \(M_1\)
and \(M_2\), namely \((q_1, q_2)\). Finally, the set of accept states
is every tuple in \(Q_1\) containing a state in \(F_2\) or in \(Q_2\) containing a state in \(F_1\), namely
\(Q_1 \times F_2 \union Q_2 \times F_1\). \\
We can conclude that \(M=(Q_1 \times Q_2, \Sigma, \delta((r_1, r_2), a), (q_1, q_2), Q_1 \times F_2 \union Q_2 \times F_1)\)
accepts \(A \union B\) so \(A \union B\) is regular.

\pagebreak

\section{Nondeterministic Finite Automaton}

Nondeterministic finite automata (NFA) are state-machines
like DFAs but can change multiple states at a time by processing
empty strings \(\emptyString\) and when processing a symbol
\(a\) may have multiple possible states to switch to.
The NFA will choose the "correct" switch in order to end in an accept state, if possible.

The following automaton where \(\Sigma = \{1\}\) will end in an accept state
if the input has length which is a multiple of \(2\) or \(3\).

\newcommand\double[3][10]{%
  \draw (#2)
    edge [bend left=#1,draw=none]
    coordinate[at start](#2-#3-s)
    coordinate[at end](#2-#3-e)
    (#3)
    edge [bend right=#1,draw=none]
    coordinate[at start](#3-#2-e)
    coordinate[at end](#3-#2-s)
    (#3);
}

\begin{center}
    \begin{tikzpicture}[node distance=2cm,on grid,auto]
        \node[state] (0) {};
        \node (inv) [left=of 0] {};

        \node[state, accepting] (a1) [above right=of 0] {\(q_{a1}\)};
        \node[state] (a2) [right=of a1] {\(q_{a2}\)};
        
        \node[state, accepting] (b1) [below right=of 0] {\(q_{b1}\)};
        \node[state] (b2) [right=of b1] {\(q_{b2}\)};
        \node[state] (b3) [below=of b2] {\(q_{b3}\)};
        
        \double{a1}{a2};

        \path[->]
            (inv)
                edge node {} (0)
            (0)
                edge node {\(\emptyString\)} (a1)
                edge node {\(\emptyString\)} (b1)
            (a1-a2-s)
                edge node {\(1\)} (a1-a2-e)
            (a2-a1-s)
                edge node {\(1\)} (a2-a1-e)
            (b1)
                edge node {\(1\)} (b2)
            (b2)
                edge node {\(1\)} (b3)
            (b3)
                edge node {\(1\)} (b1);
    \end{tikzpicture}
\end{center}
The first switch is done by processing an empty string and the direction is chosen magically
in order to end in an accept state.

A NFA is defined as \(M=(Q, \Sigma, \delta, q, F)\) where
\begin{itemize}
    \item \(Q\) is a finite set of \textit{states}
    \item \(\Sigma\) is an alphabet
    \item \(\delta : Q \times \Sigma_\emptyString \to \mathcal{P}(Q)\) is the \textit{transition function}
    \item \(q\) is an element of \(Q\) called the \textit{start state}
    \item \(F\) is a subset of \(Q\) which contains the \textit{accept states}
\end{itemize}

\section{Equivalente of DFAs and NFAs}

Anything that can be computed by a NFA can also be computed by a DFA and vice versa.

\subsection{DFA to NFA conversion}

Let \(M=(Q, \Sigma, \delta, q, F)\) be a DFA.
\(\delta\) is not a transition function of a NFA, so we need to redefine it as \(\delta'\).
Since \(\delta\) cannot process \(\emptyString\), \(\delta'\)
it is defined as
\[
    \delta'(r, a)=
    \begin{cases} 
        \delta(r, a) & x \neq \emptyString \\
        \emptyset & x = \emptyString
    \end{cases}
\]
where \(r\) is a state in \(Q\) and \(a\) is a symbol in \(\Sigma_\emptyString\). \\
We can conclude that \(N=(Q, \Sigma, \delta', q, F)\).

\subsection{NFA to DFA conversion}

Let \(N=(Q, \Sigma, \delta, q, F)\) be a NFA. The idea is to construct a DFA \(M=(Q', \Sigma, \delta', q', F')\)
that runs all the possible combinations that could be run by \(N\) at the same time.
Any state of \(M\) is a set of states \(R \in \mathcal{P}(Q)\), so we will say that
\(Q'=\mathcal{P}(Q)\). The set of accept states is any state \(R\) which contains an accept
state of \(N\)
\[
    F' = \{R \in Q' \suchthat R \intersection F \neq \emptyset\}
\]
Let's assume that \(N\) does not execute any \(\emptyString\)-transitions.
\(q'\) would be \(\{q\}\) and \(\delta'\) would be
\[
    \delta'(R, a) = \bigcup_{r\in R}\delta(r,a)
\]
which is the union of all possible states \(N\) could switch to.
Recall that for every \(r\in R\), \(\delta(r,a)\) is a set
of all possible states to switch to.

Let's now remove the previous assumption. Now, \(M\)
must also consider every state that could be reached by
making zero or more \(\emptyString\)-transitions.
The \(\emptyString\)-closure
for a state \(r\), \(C_\emptyString(r)\), is defined as
the set of all possible states that can be reached from \(r\) by making
zero or more \(\emptyString\)-transitions.
The \(\emptyString\)-closure for a set of states \(R\) is defined as
\[
    C_\emptyString(R) = \bigcup_{r\in R}C_\emptyString(r)
\]
The initial state \(q'\) is now given by \(C_\emptyString(q)\)
and the transition function
\[
    \delta'(R, a) = \bigcup_{r\in R}C_\emptyString(\delta(r, a))
\]

\section{Closure under regular operations}

We proved using DFAs that if \(A\) and \(B\) are two regular languages over \(\Sigma\), then \(A\union B\)
is also regular.
\[
    \exists M \suchthat L(M) = A \union B
\]
We can prove the closure under regular operations using NFAs.

\subsection{Closure under union}

\textit{If \(A\) and \(B\) are two regular languages over the same alphabet
\(\Sigma\), then \(A \union B\) is also regular.}

Let \(N_1 = (Q_1, \Sigma, \delta_1, q_1, F_1)\) and
\(N_2 = (Q_2, \Sigma, \delta_2, q_2, F_2)\) be two NFAs such that
\(A_1 = L(N_1)\) and \(A_2 = L(N_2)\).
We can construct another NFA \(N=(Q, \Sigma, \delta, q_0, F)\)
such that \(L(N)=A\union B\).
\(N\) will either go to \(N_1\) or \(N_2\) by making a \(\emptyString\)-transition.
\begin{itemize}
    \item \(Q=\{q_0\} \union Q_1 \union Q_2\)
    \item \(F=F_1 \union F_2\)
    \item \[
        \delta(r, a) =
        \begin{cases}
            \delta_1(r, a) & r \in Q_1 \\
            \delta_2(r, a) & r \in Q_2 \\
            \{q_1, q_2\} & r = \emptyString \\
            \emptyset & r \neq \emptyString
        \end{cases}
    \]
\end{itemize}

\begin{center}
    \begin{tikzpicture}[node distance=2cm,on grid,auto]
        \node[state] (0) {\(q_0\)};
        \node (inv) [left=of 0] {};

        \node[state] (a1) [above right=of 0] {\(N_1\)};
        
        \node[state] (b1) [below right=of 0] {\(N_2\)};
        
        \path[->]
            (inv)
                edge node {} (0)
            (0)
                edge node {\(\emptyString\)} (a1)
                edge node {\(\emptyString\)} (b1);
    \end{tikzpicture}
\end{center}

\subsection{Closure under concatenation}

\textit{If \(A\) and \(B\) are two regular languages over the same alphabet
\(\Sigma\), then \(AB\) is also regular.}

Let \(N_1 = (Q_1, \Sigma, \delta_1, q_1, F_1)\) and
\(N_2 = (Q_2, \Sigma, \delta_2, q_2, F_2)\) be two NFAs such that
\(A_1 = L(N_1)\) and \(A_2 = L(N_2)\).
We can construct another NFA \(N=(Q, \Sigma, \delta, q_0, F)\)
such that \(L(N)=AB\).
\(N\) will start by executing \(N_1\), meaning \(q_0=q_1\). If \(N\) switches to a state
\(r\in F_1\) it can move to executing \(N_2\) with a \(\emptyString\)-transition.
The accepted states are only the ones of \(N_2\) meaning \(F=F_2\). \(Q=Q_1 \union Q_2\).
The transition function is hence defined as
\[
    \delta(r, a)
    \begin{cases}
        \delta_1(r, a) & (r \in Q_1 \land r \notin F_1) \lor (r \in F_1 \land r \neq \emptyString) \\
        \delta_1(r, a) \union \{q_2\} & r \in F_1 \land r = \emptyString \\
        \delta_2(r, a) & r \in Q_2
    \end{cases}
\]

\begin{center}
    \begin{tikzpicture}[node distance=2cm,on grid,auto]
        \node[state] (q0) {\(q_0\)};
        \node (inv) [left=of q0] {};

        \node[state] (q1) [right=of q0] {\(q_1\)};
        \node[state] (q2) [below=of q0] {\(q_2\)};
        \node[state] (q3) [below=of q1] {\(q_3\)};
        \node[state] (q4) [below=of q2] {\(q_4\)};
        \node[state] (q5) [below=of q3] {\(q_5\)};

        \node[state] (n2) [right=of q3] {\(N_2\)};

        \draw[draw=black] (q0) ++(-0.5, 0.5) rectangle ++(3,-5) node[below] {\(N_1\)};

        \path[->]
            (inv)
                edge node {} (q0)
            (q1)
                edge node {\(\emptyString\)} (n2)
            (q3)
                edge node {\(\emptyString\)} (n2)
            (q5)
                edge node {\(\emptyString\)} (n2);
    \end{tikzpicture}
\end{center}
Here \(F_1 = \{q_1, q_3, q_5\}\) but the actual accept states are the ones for \(N_2\).

\subsection{Closure under Kleene star}

\textit{If \(A\) is a regular language, then \(A^*\) is also regular.}

Let \(N_1 = (Q_1, \Sigma, \delta_1, q_0, F_1)\) be a NFAs such that
\(A_1 = L(N_1)\). We can construct another NFA \(N=(Q, \Sigma, \delta, q, F)\)
such that \(L(N)=A_1^*\).
We want \(N_1\) to be able to switch back to its initial point
when it is in a state \(r \in F_1\). This means that the concatenation of
accepted strings can cycle one after the other. Since \(\emptyString\)
also needs to be accepted we need a new start state which is an accept state.

\begin{itemize}
    \item \(Q = \{q_a\} \union Q_1\)
    \item \(q = q_a\)
    \item \(F = F_1 \union \{q\}\)
    \item \[
        \delta(r,a) =
        \begin{cases}
            \delta_1(r,a) & (r \in Q_1 \land r \notin F_1) \lor (r \in F_1 \land a \neq \emptyString) \\
            \delta_1(r,a) \union \{q\} & r \in F_1 \land a = \emptyString \\
            \{q\} & r = q \land a = \emptyString \\
            \emptyset & r = q \land a \neq \emptyString
        \end{cases}
    \]
\end{itemize}

\begin{center}
    \begin{tikzpicture}[node distance=2cm,on grid,auto]
        \node[state, accepting] (q) {\(q\)};
        \node[state] (q0) [right=of q] {\(q_0\)};
        \node (inv) [left=of q0] {};

        \node[state, accepting] (q1) [right=of q0] {\(q_1\)};
        \node[state] (q2) [below=of q0] {\(q_2\)};
        \node[state, accepting] (q3) [below=of q1] {\(q_3\)};
        \node[state] (q4) [below=of q2] {\(q_4\)};
        \node[state, accepting] (q5) [below=of q3] {\(q_5\)};

        \draw[draw=black] (q0) ++(-0.5, 0.5) rectangle ++(3,-5);

        \path[->]
            (inv)
                edge node {\(\emptyString\)} (q0)
            (q1)
                edge node {\(\emptyString\)} (q0)
            (q3)
                edge node {\(\emptyString\)} (q0)
            (q5)
                edge node {\(\emptyString\)} (q0);
    \end{tikzpicture}
\end{center}

\subsection{Closure under complement}

\textit{If \(A\) is a regular language, then \(\bar{A}\) is also regular.}

Let \(N_1 = (Q_1, \Sigma, \delta_1, q_0, F_1)\) be a NFAs such that
\(A_1 = L(N_1)\). We can construct another NFA \(N=(Q, \Sigma, \delta, q, F)\)
such that \(L(N)=\bar{A_1}\).
Any state \(r \notin F_1\) will be able to switch to a new state \(q_a\),
which is the only accept state of \(N\), with a \(\emptyString\)-transition.
This will negate any accepting state of \(N_1\) and vice versa.

\begin{itemize}
    \item \(Q=\{q_a\} \union Q_1\)
    \item \(q = q_0\)
    \item \(F = \{q_a\}\)
    \item \[
        \delta(r,a) =
        \begin{cases}
            \delta_1(r,a) \union \{q_a\} & r \in F_1 \\
            \delta_1(r,a) & r \notin F_1 \\
        \end{cases}
    \]
\end{itemize}

\begin{center}
    \begin{tikzpicture}[node distance=2cm,on grid,auto]
        \node[state] (q0) {\(q_0\)};
        \node (inv) [left=of q0] {};

        \node[state] (q1) [right=of q0] {\(q_1\)};
        \node[state] (q2) [below=of q0] {\(q_2\)};
        \node[state] (q3) [below=of q1] {\(q_3\)};
        \node[state] (q4) [below=of q2] {\(q_4\)};
        \node[state] (q5) [below=of q3] {\(q_5\)};

        \node[state] (n2) [right=of q3] {\(q_a\)};

        \draw[draw=black] (q0) ++(-0.5, 0.5) rectangle ++(3,-5);

        \path[->]
            (inv)
                edge node {} (q0)
            (q1)
                edge node {\(\emptyString\)} (n2)
            (q3)
                edge node {\(\emptyString\)} (n2)
            (q5)
                edge node {\(\emptyString\)} (n2);
    \end{tikzpicture}
\end{center}
Here \(F_1=\{q_0, q_2, q_4\}\), but the only actual accept state is \(q_a\).

\subsection{Closure under intersection}

\textit{If \(A\) and \(B\) are two regular languages over the same alphabet
\(\Sigma\), then \(A \intersection B\) is also regular.}

Since \(A\union B\) is regular and \(A \intersection B \subseteq A \union B\),
\(A \intersection B\) is also regular.

\section{Regular Expression}

\end{document}

% https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf
% pag 60