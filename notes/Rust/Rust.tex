\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{listings,listings-rust}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    pdftitle={Rust},
    pdfpagemode=FullScreen,
}

\title{The Rust programming language}
\author{Paolo Bettelini}
\date{}

\begin{document}

\maketitle
\tableofcontents
\pagebreak

\section{Basic Types}

%\subsection{Boolean}
%\subsection{Numbers}
%\subsubsection{Signed integers}
%\subsubsection{Unsigned integers}
%\subsubsection{Floating points}
%\subsection{Text}

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
// boolean
bool

// signed integers
i8, i16, i32, i64, i128, isize

// unsigned integers
u8, u16, u32, u64, u128, usize

// floating points
f32, f64

// Text
char, String, str
\end{lstlisting}

\section{Tuples}

Tuples are a combination of multiple types.
Tuples can contain any number of types and/or other tuples.

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
let coordinates = (101, 3, 4);
let person = ("Paolo", "Bettelini", 18);
let status: (bool, (u128, i32)) = (true, (1u128, 2));
\end{lstlisting}

\section{Loops}

\subsection{Returning from loops}

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
let mut counter = 0;

let result = loop {
    counter += 1;

    if counter == 10 {
        break counter;
    }
};
\end{lstlisting}

\subsection{Labels}

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
'outer: loop {
    'inner: loop {
        // This breaks the inner loop
        break;
        // This breaks the outer loop
        break 'outer;
    }
}
\end{lstlisting}

\subsection{Returning from labelled loops}

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
let mut counter = 0;

let result = 'outer: loop {
    counter += 1;

    if counter == 10 {
        break 'outer counter;
    }
};
\end{lstlisting}

\section{Pattern Matching}

\subsection{Basic}

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
    let x = 5;
    
    match x {
      // matching literals
      1 => println!("one"),
      // matching multiple patterns
      2 | 3 => println!("two or three"),
      // matching ranges
      4..=9 => println!("within range"),
      // matching named variables
      x => println!("{}", x),
      // default case (ignores value)
      _ => println!("default Case")
    }
\end{lstlisting}

\pagebreak

\subsection{Destructuring}

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
    struct Point {
        x: i32,
        y: i32,
      }
      
      let p = Point { x: 0, y: 7 };
      
      match p {
        Point { x, y: 0 } => {
          println!("{}" , x);
        },
        Point { x, y } => {
          println!("{} {}" , x, y);
        },
      }
      
      enum Shape {
        Rectangle { width: i32, height: i32 },
        Circle(i32),
      }
      
      let shape = Shape::Circle(10);
      
      match shape {
        Shape::Rectangle { x, y } => //...
        Shape::Circle(radius) => //...
      }
\end{lstlisting}

\subsection{Ignoring values}

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
    struct SemVer(i32, i32, i32);

    let version = SemVer(1, 32, 2);
    
    match version {
      SemVer(major, _, _) => {
        println!("{}", major);
      }
    }
    
    let numbers = (2, 4, 8, 16, 32);
    
    match numbers {
      (first, .., last) => {
        println!("{}, {}", first, last);
      }
    }
\end{lstlisting}

\pagebreak

\subsection{Match guards}

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
    let num = Some(4);

    match num {
      Some(x) if x < 5 => println!("less than five: {}", x),
      Some(x) => println!("{}", x),
      None => (),
    }
\end{lstlisting}

\subsection{@ bindings}

Bind value to a name

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
  match beaufort() {
    v @ 0..1    => println!("Calm : {} km/h", v),
    v @ 1..=5   => println!("Light Air : {} km/h", v),
    v @ 5..=11  => println!("Light Breeze : {} km/h", v),
    v @ 11..=19 => println!("Gentle Breeze : {} km/h", v)
  }
\end{lstlisting}

\pagebreak

\section{Option}

A function that may fail might enclose its return value in an
\textbf{Option} enum, to notify wheter the action was successful.

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
  fn sqrt(v: f64) -> Option<(f64, f64)> {
    if v < 0.0 {
      return None;
    }

    let sqrt = v.sqrt();
    Some((sqrt, -sqrt))
  }
\end{lstlisting}

\section{Result}

\subsection{Definition}

The \textbf{Result} enum is similar to \textbf{Option} but it
specifies why the function has failed.

When the function doesn't really need to return anything other than the
\textbf{Result} status, \textbf{()} can be used.

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
  enum ErrorType {
    NegativeBase,
    NegativeArgument,
    BaseOne
  }
  
  fn log(base: f64, arg: f64) -> Result<f64, ErrorType> {
    if base <= 0.0 {
      return Err(ErrorType::NegativeBase);
    }

    if base == 1.0 {
      return Err(ErrorType::BaseOne);
    }

    if arg <= 0.0 {
      return Err(ErrorType::NegativeArgument);
    }

    let result = arg.log(base);
    Ok(result)
  }
\end{lstlisting}

\pagebreak

\subsection{? operator}

The \textbf{?} operator is syntax sugar for \textbf{Result} handling. \\
This operator can be placed at the end of a \textbf{Result} type.
If the result is an error, the functions returns it, otherwise unwraps
its value.

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
  fn log(base: f64, arg: f64) -> Result<f64, ErrorType> { ... }

  fn something() -> Result<f64, ErrorType> {
    let v = match log(2.718, 3.14) {
      Ok(v) => v,
      Err(e) => return Err(e)
    };

    // use `v`
  }
\end{lstlisting}

can be written as

\begin{lstlisting}[language=Rust, style=boxed, numbers=none]
  fn log(base: f64, arg: f64) -> Result<f64, ErrorType> { ... }

  fn something() -> Result<f64, ErrorType> {
    let v = log(2.718, 3.14)?;

    // use `v`
  }
\end{lstlisting}

\end{document}

% https://docs.google.com/document/d/1kQidzAlbqapu-WZTuw4Djik0uTqMZYyiMXTM9F21Dz4/edit