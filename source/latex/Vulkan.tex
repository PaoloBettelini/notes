\documentclass[preview]{standalone}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{stellar}
\usepackage{definitions}

\lstdefinelanguage{GLSL}%
{%
    morekeywords={%
    % HLSL constants
        false,FALSE,NULL,true,TRUE,%
    % GLSL predefinde macro constant
        __LINE__,__FILE__,__VERSION__,GL_core_profile,GL_es_profile,GL_compatibility_profile,%
    % GLSL precision modifier
        precision,highp,mediump,lowp,%
    % GLSL control keywords
        break,case,continue,default,discard,do,else,for,if,return,switch,while,%
    % GLSL types
        void,bool,int,uint,float,double,vec2,vec3,vec4,dvec2,dvec3,dvec4,bvec2,bvec3,bvec4,ivec2,ivec3,ivec4,uvec2,uvec3,uvec4,mat2,mat3,mat4,mat2x2,mat2x3,mat2x4,mat3x2,mat3x3,mat3x4,mat4x2,mat4x3,mat4x4,dmat2,dmat3,dmat4,dmat2x2,dmat2x3,dmat2x4,dmat3x2,dmat3x3,dmat3x4,dmat4x2,dmat4x3,dmat4x4,sampler1D,sampler2D,sampler3D,image1D,image2D,image3D,samplerCube,imageCube,sampler2DRect,image2DRect,sampler1DArray,sampler2DArray,image1DArray,image2DArray,samplerBuffer,imageBuffer,sampler2DMS,image2DMS,sampler2DMSArray,image2DMSArray,samplerCubeArray,imageCubeArray,sampler1DShadow,sampler2DShadow,sampler2DRectShadow,sampler1DArrayShadow,sampler2DArrayShadow,samplerCubeShadow,samplerCubeArrayShadow,isampler1D,isampler2D,isampler3D,iimage1D,iimage2D,iimage3D,isamplerCube,iimageCube,isampler2DRect,iimage2DRect,isampler1DArray,isampler2DArray,iimage1DArray,iimage2DArray,isamplerBuffer,iimageBuffer,isampler2DMS,iimage2DMS,isampler2DMSArray,iimage2DMSArray,isamplerCubeArray,iimageCubeArray,atomic_uint,usampler1D,usampler2D,usampler3D,uimage1D,uimage2D,uimage3D,usamplerCube,uimageCube,usampler2DRect,uimage2DRect,usampler1DArray,usampler2DArray,uimage1DArray,uimage2DArray,usamplerBuffer,uimageBuffer,usampler2DMS,uimage2DMS,usampler2DMSArray,uimage2DMSArray,usamplerCubeArray,uimageCubeArray,struct,%
    % GLSL support variables
        gl_BackColor,gl_BackLightModelProduct,gl_BackLightProduct,gl_BackMaterial,gl_BackSecondaryColor,gl_ClipDistance,gl_ClipPlane,gl_ClipVertex,gl_Color,gl_DepthRange,gl_DepthRangeParameters,gl_EyePlaneQ,gl_EyePlaneR,gl_EyePlaneS,gl_EyePlaneT,gl_Fog,gl_FogCoord,gl_FogFragCoord,gl_FogParameters,gl_FragColor,gl_FragCoord,gl_FragData,gl_FragDepth,gl_FrontColor,gl_FrontFacing,gl_FrontLightModelProduct,gl_FrontLightProduct,gl_FrontMaterial,gl_FrontSecondaryColor,gl_InstanceID,gl_Layer,gl_LightModel,gl_LightModelParameters,gl_LightModelProducts,gl_LightProducts,gl_LightSource,gl_LightSourceParameters,gl_MaterialParameters,gl_ModelViewMatrix,gl_ModelViewMatrixInverse,gl_ModelViewMatrixInverseTranspose,gl_ModelViewMatrixTranspose,gl_ModelViewProjectionMatrix,gl_ModelViewProjectionMatrixInverse,gl_ModelViewProjectionMatrixInverseTranspose,gl_ModelViewProjectionMatrixTranspose,gl_MultiTexCoord0,gl_MultiTexCoord1,gl_MultiTexCoord2,gl_MultiTexCoord3,gl_MultiTexCoord4,gl_MultiTexCoord5,gl_MultiTexCoord6,gl_MultiTexCoord7,gl_Normal,gl_NormalMatrix,gl_NormalScale,gl_ObjectPlaneQ,gl_ObjectPlaneR,gl_ObjectPlaneS,gl_ObjectPlaneT,gl_Point,gl_PointCoord,gl_PointParameters,gl_PointSize,gl_Position,gl_PrimitiveIDIn,gl_ProjectionMatrix,gl_ProjectionMatrixInverse,gl_ProjectionMatrixInverseTranspose,gl_ProjectionMatrixTranspose,gl_SecondaryColor,gl_TexCoord,gl_TextureEnvColor,gl_TextureMatrix,gl_TextureMatrixInverse,gl_TextureMatrixInverseTranspose,gl_TextureMatrixTranspose,gl_Vertex,gl_VertexID,%
    % GLSL support constants
        gl_MaxClipPlanes,gl_MaxCombinedTextureImageUnits,gl_MaxDrawBuffers,gl_MaxFragmentUniformComponents,gl_MaxLights,gl_MaxTextureCoords,gl_MaxTextureImageUnits,gl_MaxTextureUnits,gl_MaxVaryingFloats,gl_MaxVertexAttribs,gl_MaxVertexTextureImageUnits,gl_MaxVertexUniformComponents,%
    % GLSL support functions
        abs,acos,all,any,asin,atan,ceil,clamp,cos,cross,degrees,dFdx,dFdy,distance,dot,equal,exp,exp2,faceforward,floor,fract,ftransform,fwidth,greaterThan,greaterThanEqual,inversesqrt,length,lessThan,lessThanEqual,log,log2,matrixCompMult,max,min,mix,mod,noise1,noise2,noise3,noise4,normalize,not,notEqual,outerProduct,pow,radians,reflect,refract,shadow1D,shadow1DLod,shadow1DProj,shadow1DProjLod,shadow2D,shadow2DLod,shadow2DProj,shadow2DProjLod,sign,sin,smoothstep,sqrt,step,tan,texture1D,texture1DLod,texture1DProj,texture1DProjLod,texture2D,texture2DLod,texture2DProj,texture2DProjLod,texture3D,texture3DLod,texture3DProj,texture3DProjLod,textureCube,textureCubeLod,transpose,%
    % GLSL struct member -> FixMe: Should have dot(.) as delimiter
        rgb
    },
    sensitive=true,%
    morecomment=[s]{/*}{*/},%
    morecomment=[l]//,%
    morestring=[b]",%
    morestring=[b]',%
    moredelim=*[directive]\#,%
    % keyword.control.hlsl
    moredirectives={define,defined,elif,else,if,ifdef,endif,line,error,ifndef,include,pragma,undef,warning,extension,version}%
}[keywords,comments,strings,directives]%

\begin{document}

\id{vulkan}
\genpage

\section{Vulkan}

\begin{snippetdefinition}{vulkan-definition}{Vulkan}
    \textit{Vulkan} is a multi-platform low-level graphical interface (API)
    for GPU rendering.
\end{snippetdefinition}

%%%%%%%%%%%%%%%%%%%

\section{Instance}

A Vulkan application starts by setting up the API through a vulkan instance
(\textbf{VkInstance}).

\section{Physical Device}

We can query the API for Vulkan supported hardware and select
one o more physical devices (\textbf{VkPhysicalDevice}) to use for our operations.
We can query for different capabilities, VRAM size, etc.

\section{Logical Device}

Given a phyical device we can create a logical device (\textbf{VkDevice}).
The logical device represents an open channel with the physical device.
it also describes which features (\textbf{VkPhysicalDeviceFeatures}) we will be using.

\section{Queue}

The GPU is able to run multiple operations in parallel.
The equivalent of a CPU thread is a queue (\textbf{VkQueue}).

\section{Queue family}

Queues are grouped by queue families.

Whenever we want the device to perform an operation,
we have to submit this operation to a specific queue under a family.
Some families support only graphical operations,
some others support only compute operations, and some others support both
and or other operations.

\section{Buffers}

When we need the GPU to read or write data in memory,
we need to use a \textbf{buffer} (or an image, later section).

\section{Command buffers}

To execute an operation we need to create a command buffer
containg a list of commands to execute.

To submit a command buffer we need to synchronize with the GPU.
We can also tell the GPU to send back a signal, call \textbf{fence} when
the operation is done.

\subsection{Primary command buffers}

They can contain any command.
They are the only type of command buffer that can be submitted to a queue.

\subsection{Secondary command buffers}

They allow you to store functionality that you can reuse multiple times in primary command buffers. 

\section{Compute pipelines}

In order to ask the GPU to perform an operation on some data, we need to write
a program for it. A program that runs on the GPU is called a shader.

Shaders are written in a shading language (hlsl, glsl, wgpu, rust-gpu, ...)
which is then compiled into an intermediate bytecode called \textbf{SPIR-V}.

\section{Descriptors}

When we create a compute pipeline for a shader we must bound it to a \textbf{descriptor}.
A descriptor can contain a buffer to access, buffer viewes, images, samples images etc.

Descriptors are grouped by \textbf{descriptor sets}.
The shader will declare a specific descriptor from a specific set (both indexed from 0).

\section{Dispatch}

To execute a compute pipeline we need to create a command buffer to do so.
This is called \textbf{Dispatch}.

% The layout(set = 0, binding = 0) attribute in the GLSL code indicates that this descriptor
% is the descriptor 0 in the set 0. Descriptor indices and set indices are 0-based.

\section{Images}

Another way to make the GPU interact with memory is with an \textbf{image}.
Images are often 2-dimensional array of pixels (there also also 3-dimensional images). The pixels of the image
are often referred to as \textbf{texels}.

Each pixel can have up to four components.

You can't directly change the content of an image as you would for a buffer.
For example, we could create a command buffer to tell the GPU to fill an image with white pixels.

\section{Graphics pipelines}

A graphics pipeline is the same as a compute pipeline but for graphical operations.
Graphics pipelines are more restrictive than compute operations, but they're also much faster.

The purpose of this pipeline is to draw a shape on an image.

Both types of pipelines are represented by \textbf{VkPipeline}.
It represents the state of the GPU, such as viewport, depth buffer, shaders and so on.

\subsection{Vertex shaders}

The first step when executing a graphics operation is the \textbf{vertex shader}.
This shader is executed for each vertex of the shape.

The vertex shader must output the final position (\texttt{gl\_Position}) for the shape.
The vertex struct usually only contains the position of the vertex, so that the shader
can set \texttt{gl\_Position} accordingly. However, a vertex shader can have multiple inputs and output.
For example, we could pass \texttt{position} and \texttt{color} for each vertex.

\begin{lstlisting}[language=GLSL, caption={Vertex Shader}]
    #version 450

    layout(location = 0) in vec2 position;
    layout(location = 1) in vec3 color;
    
    // to frag shader
    layout(location = 0) out vec3 fragColor;
    
    void main() {
        gl_Position = vec4(position, 0.0, 1.0);
        fragColor = color;
    }
\end{lstlisting}

\subsection{Fragment shaders}

The GPU will compute which pixels are in the given final shape, and
will execute for each of them the \textbf{fragment shader}.
Each output of the vertex shader will be available to the fragment shader
and will have a smooth interpolation between all the vertex positions.
For example, the last vertex shader will call the fragment shader
for each pixel within the shape, also passing for each pixel
an interpolated color between the colors of the other vertices.

The fragment shader will output the color for that pixel.

\begin{lstlisting}[language=GLSL, caption={Fragment Shader}]
    #version 450
            
    layout(location = 0) out vec4 f_color;
    layout(location = 0) in vec3 fragColor;
    
    void main() {
        f_color = vec4(fragColor, 1.0);
    }
\end{lstlisting}

\subsection{Vertex buffer}

Vertex buffer is the name given the the buffer containing the vertices
of the shape (and other attributes) passed to the vertex shader.
The shape is made out of triangles (3 vertices each).

\subsection{Render passes}

Before executing a graphics operation we must tell the GPU to enter a "rendering mode",
by entering what is called a \textbf{render pass}.
The render pass describes the type of images that are used
during rendering operations, how they are used and how they should be treated.

A render pass is made of \textbf{attachments} and \textbf{passes}.

\section{Windows}

Rendering to a window.

\subsection{Surface}

A handle to a surface object (\textbf{VkSurfaceKHR}).

\subsection{Swapchain}

A swapchain is a collection of one or mutliple images.
It is used to draw onto the screen images only when they're done rendering.
A swapchain may have one, two (\textit{double buffering}) or most commonly three
(\textit{triple buffering}) swapchain images.

The swapchain will provide us with an image to draw to when needed.



% SETTINGS
%Surface format
%Presentation mode
%Swap extent


% vk::SharingMode::CONCURRENT


% indexes


% creat an instance
% enumerate physical devices and pick one
% get a family that supported graphics
% create a device (represents an open channel with the physical device) 
%   with the family
%   this will return the device and the queues
% [ COMMAND
%   Create buffer(s)
%   Create primary command buffer
%   sync cpu
% ]
% [ COMPUTE SHADER
%   create buffer
%   create descriptor
%   create compute shader
%   create compute pipeline (shader)
%   bind descriptor
%   create command buffer to execute pipeline. (Dispath)
%   sync
% ]
% [ GRAPHICS SHADER
%   create vertex shader
%   create fragment shader
%   create graphics pipeline (vertex, fragment)
%   create N buffers containing the vertices
%   create a framebuffer which is a collection of images to write to.
%   create command_buffer
%   sync
% ]

\end{document}

% https://vulkano.rs/guide/


https://vulkano.rs/guide/compute-pipeline
workgroups

https://vulkano.rs/guide/what-graphics-pipeline