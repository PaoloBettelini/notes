\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{fancybox}
\usepackage{makecell}
\usepackage{stackengine}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    pdftitle={Stellar},
    pdfpagemode=FullScreen,
}

\definecolor{background}{HTML}{EEEEEE}

\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=none,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    stringstyle=\ttfamily\color{red!50!brown},
	morestring=*[d]{"},
    backgroundcolor=\color{background}
}

\author{Paolo Bettelini}
\date{}

\begin{document}

\maketitle
\tableofcontents
\pagebreak

\section{Compiler}

The life of a program looks as follows:

\begin{center}
\textbf{
    Source code \(\rightarrow\) compiler \(\rightarrow\) \stackanchor{bytecode}{machine code} \(\rightarrow\) \stackanchor{VM}{CPU}
}
\end{center}

However the compiler is not straightforward

\renewcommand{\boxed}[1]{\text{\fboxsep=.2em\fbox{\m@th$\displaystyle#1$}}}

\[
    \textbf{Source code} \rightarrow
    \overbrace{
        \fbox{
            \textbf{Lexer} \rightarrow
            \textbf{Parser} \rightarrow
            \textbf{Validator} \rightarrow
            \textbf{Assembler}    
        }
    }^\text{Compiler} \rightarrow
    \textbf{\stackanchor{Bytecode}{Machine code}} \rightarrow
    \textbf{\stackanchor{VM}{CPU}}
\]

\subsection{Lexer}

The lexer takes the sources code and produces a list of tokens.

Here's an example of token design.

\begin{lstlisting}[language=json]
[
    {
        "type": "identifier",
        "value": "function"
    },
    {
        "type": "identifier",
        "value": "if"
    },
    {
        "type": "identifier",
        "value": "while"
    },
    {
        "type": "literal",
        "value": 42
    },
    {
        "type": "operator",
        "value": "{"
    },
    {
        "type": "operator",
        "value": "}"
    },
    {
        "type": "operator",
        "value": ";"
    }
]
\end{lstlisting}

\pagebreak

\subsection{Parser}

The parser takes as input the tokens generated by the lexer.
It produces an \textbf{AST} (Abstract Syntax Tree).

Here's an example of an abstract syntax tree.

\begin{center}
    \begin{tikzpicture}[
        level 1/.style = {sibling distance = 5cm},
        level 2/.style = {sibling distance = 2.5cm},
        level 3/.style = {sibling distance = 1.75cm},
        level 4/.style = {sibling distance = 0.9cm}
    ]
    \node {\fbox{\makecell{while}}}
        child {
            node {\fbox{\makecell{>}}}
            child {
                node {\ovalbox{\makecell{a}}}
            }
            child {
                node {\ovalbox{\makecell{42}}}
            }
        }
        child {
            node {\fbox{\makecell{if}}}
            child {
                node {\fbox{\makecell{>}}}
                child {
                    node {\ovalbox{b}}
                }
                child {
                    node {\ovalbox{42}}
                }
            }
            child {
                node {\ovalbox{\makecell{=}}}
                child {
                    node {\ovalbox{x}}
                }
                child {
                    node {\fbox{+}}
                    child {
                        node {\ovalbox{x}}
                    }
                    child {
                        node {\ovalbox{1}}
                    }
                }
            }
        };
    \end{tikzpicture}
\end{center}

\subsection{Validator}

The validator checks for any error in the AST.
It checks if every variable exists, function calls are valid and so on.

\subsection{Assembler}

The assembler takes the AST and produces the final compiled code.

\end{document}
